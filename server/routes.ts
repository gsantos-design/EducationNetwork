import type { Express, Request, Response, NextFunction } from "express";
import { createServer, type Server } from "http";
import { setupAuth } from "./auth";
import { storage } from "./storage";
import { UserRole, AdminLevel, User, InsertAchievement, Achievement, insertAchievementSchema, insertTutoringSessionSchema, insertTutoringMessageSchema } from "@shared/schema";
import { z } from "zod";
import { getTutorResponse, generateSessionSummary, type TutorMessage } from "./anthropic";

// Role-based access control middleware
function requireRole(roles: UserRole[]) {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Authentication required" });
    }
    
    const user = req.user as User;
    if (!roles.includes(user.role as UserRole)) {
      return res.status(403).json({ message: "Access denied" });
    }
    
    next();
  };
}

// Access control middleware for hierarchical admin permissions
function requireAdminAccess(level: AdminLevel) {
  return async (req: Request, res: Response, next: NextFunction) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Authentication required" });
    }
    
    const user = req.user as User;
    if (user.role !== UserRole.ADMIN) {
      return res.status(403).json({ message: "Admin access required" });
    }
    
    // Super admin without specified adminLevel can access everything
    if (!user.adminLevel) {
      return next();
    }
    
    // Check admin access levels
    const adminLevelHierarchy = {
      [AdminLevel.DISTRICT]: 3, // Highest level
      [AdminLevel.SCHOOL]: 2,
      [AdminLevel.DEPARTMENT]: 1 // Lowest level
    };
    
    const requiredLevel = adminLevelHierarchy[level];
    const userLevel = adminLevelHierarchy[user.adminLevel as AdminLevel];
    
    if (userLevel >= requiredLevel) {
      return next();
    }
    
    return res.status(403).json({ 
      message: `Access denied: ${level} admin access required` 
    });
  };
}

// Filtered data access middleware that adds user context to storage calls
function withUserContext(req: Request, res: Response, next: NextFunction) {
  if (!req.isAuthenticated()) {
    return res.status(401).json({ message: "Authentication required" });
  }
  
  // Add user context to the request for later use
  req.userContext = req.user as User;
  next();
}

export async function registerRoutes(app: Express): Promise<Server> {
  // Set up authentication routes
  setupAuth(app);

  // API routes
  
  // Learning Path API endpoint
  app.get("/api/learning-paths", withUserContext, async (req, res, next) => {
    try {
      const user = req.userContext as User;
      let learningPaths = [];
      
      if (user.role === UserRole.STUDENT) {
        // For students, get personalized learning paths
        const student = await storage.getStudentByUserId(user.id);
        if (!student) return res.status(404).json({ message: "Student record not found" });
        
        // Get classes the student is enrolled in
        const enrollments = await storage.getEnrollmentsByStudentId(student.id);
        
        // Get grades to analyze strengths and weaknesses
        const grades = await storage.getGradesByStudentId(student.id);
        
        // Group grades by class
        const classProficiency: Record<string, { 
          totalScore: number, 
          maxScore: number, 
          count: number 
        }> = {};
        
        for (const grade of grades) {
          const cls = await storage.getClass(grade.classId);
          if (!cls) continue;
          
          if (!classProficiency[cls.name]) {
            classProficiency[cls.name] = {
              totalScore: 0,
              maxScore: 0,
              count: 0
            };
          }
          
          classProficiency[cls.name].totalScore += grade.score;
          classProficiency[cls.name].maxScore += grade.maxScore;
          classProficiency[cls.name].count += 1;
        }
        
        // Create sample learning paths with mock data for now
        // In a real system, these would be retrieved from a database or generated by AI
        learningPaths = [
          {
            id: "math-path-1",
            title: "Algebra Mastery Path",
            description: "Master foundational and advanced algebraic concepts with progressive learning modules",
            subject: "Mathematics",
            progress: calculateClassProgress(classProficiency, "Mathematics"),
            nodes: [
              {
                id: "algebraic-expressions",
                title: "Algebraic Expressions",
                description: "Learn to interpret and write algebraic expressions",
                status: "completed",
                type: "concept",
                dependencies: [],
                progress: 100,
                score: 92,
                subject: "Mathematics",
                estimatedHours: 2,
                difficulty: "beginner"
              },
              {
                id: "solving-equations",
                title: "Solving Equations",
                description: "Techniques for solving basic algebraic equations",
                status: "completed",
                type: "skill",
                dependencies: ["algebraic-expressions"],
                progress: 100,
                score: 85,
                subject: "Mathematics",
                estimatedHours: 4,
                difficulty: "beginner"
              },
              {
                id: "inequalities",
                title: "Inequalities",
                description: "Solving and graphing inequalities",
                status: "in-progress",
                type: "skill",
                dependencies: ["solving-equations"],
                progress: 65,
                subject: "Mathematics",
                estimatedHours: 3,
                difficulty: "intermediate"
              },
              {
                id: "systems-of-equations",
                title: "Systems of Equations",
                description: "Solving systems of linear equations",
                status: "not-started",
                type: "skill",
                dependencies: ["solving-equations"],
                progress: 0,
                subject: "Mathematics",
                estimatedHours: 5,
                difficulty: "intermediate"
              },
              {
                id: "quadratic-equations",
                title: "Quadratic Equations",
                description: "Solving quadratic equations using various methods",
                status: "not-started",
                type: "concept",
                dependencies: ["solving-equations"],
                progress: 0,
                subject: "Mathematics",
                estimatedHours: 6,
                difficulty: "advanced"
              },
              {
                id: "algebra-assessment",
                title: "Final Assessment",
                description: "Comprehensive test of algebraic concepts and skills",
                status: "not-started",
                type: "assessment",
                dependencies: ["inequalities", "systems-of-equations", "quadratic-equations"],
                progress: 0,
                subject: "Mathematics",
                estimatedHours: 2,
                difficulty: "advanced"
              }
            ]
          },
          {
            id: "science-path-1",
            title: "Physics Foundations",
            description: "Build a solid understanding of fundamental physics principles",
            subject: "Science",
            progress: calculateClassProgress(classProficiency, "Science"),
            nodes: [
              {
                id: "motion-basics",
                title: "Motion Basics",
                description: "Understanding distance, displacement, speed, velocity, and acceleration",
                status: "completed",
                type: "concept",
                dependencies: [],
                progress: 100,
                score: 88,
                subject: "Science",
                estimatedHours: 3,
                difficulty: "beginner"
              },
              {
                id: "newtons-laws",
                title: "Newton's Laws",
                description: "The three laws of motion and their applications",
                status: "in-progress",
                type: "concept",
                dependencies: ["motion-basics"],
                progress: 70,
                subject: "Science",
                estimatedHours: 4,
                difficulty: "intermediate"
              },
              {
                id: "forces",
                title: "Forces",
                description: "Types of forces and their effects on objects",
                status: "not-started",
                type: "skill",
                dependencies: ["newtons-laws"],
                progress: 0,
                subject: "Science",
                estimatedHours: 4,
                difficulty: "intermediate"
              },
              {
                id: "energy",
                title: "Energy",
                description: "Potential and kinetic energy concepts",
                status: "not-started",
                type: "concept",
                dependencies: ["forces"],
                progress: 0,
                subject: "Science",
                estimatedHours: 5,
                difficulty: "intermediate"
              },
              {
                id: "momentum",
                title: "Momentum",
                description: "Understanding momentum and collisions",
                status: "not-started",
                type: "skill",
                dependencies: ["forces", "energy"],
                progress: 0,
                subject: "Science",
                estimatedHours: 4,
                difficulty: "advanced"
              },
              {
                id: "physics-assessment",
                title: "Physics Assessment",
                description: "Comprehensive assessment of physics principles",
                status: "not-started",
                type: "assessment",
                dependencies: ["momentum"],
                progress: 0,
                subject: "Science",
                estimatedHours: 2,
                difficulty: "advanced"
              }
            ]
          },
          {
            id: "english-path-1",
            title: "Literary Analysis",
            description: "Develop critical reading and analysis skills",
            subject: "English",
            progress: calculateClassProgress(classProficiency, "English"),
            nodes: [
              {
                id: "reading-comprehension",
                title: "Reading Comprehension",
                description: "Strategies for understanding and interpreting texts",
                status: "completed",
                type: "skill",
                dependencies: [],
                progress: 100,
                score: 95,
                subject: "English",
                estimatedHours: 2,
                difficulty: "beginner"
              },
              {
                id: "literary-elements",
                title: "Literary Elements",
                description: "Identifying and analyzing plot, character, setting, and theme",
                status: "completed",
                type: "concept",
                dependencies: ["reading-comprehension"],
                progress: 100,
                score: 90,
                subject: "English",
                estimatedHours: 3,
                difficulty: "beginner"
              },
              {
                id: "narrative-techniques",
                title: "Narrative Techniques",
                description: "Understanding point of view, symbolism, and foreshadowing",
                status: "in-progress",
                type: "concept",
                dependencies: ["literary-elements"],
                progress: 45,
                subject: "English",
                estimatedHours: 4,
                difficulty: "intermediate"
              },
              {
                id: "critical-analysis",
                title: "Critical Analysis",
                description: "Developing critical perspectives on literature",
                status: "not-started",
                type: "skill",
                dependencies: ["narrative-techniques"],
                progress: 0,
                subject: "English",
                estimatedHours: 5,
                difficulty: "advanced"
              },
              {
                id: "essay-writing",
                title: "Essay Writing",
                description: "Crafting well-structured literary analysis essays",
                status: "not-started",
                type: "skill",
                dependencies: ["critical-analysis"],
                progress: 0,
                subject: "English",
                estimatedHours: 6,
                difficulty: "advanced"
              },
              {
                id: "english-assessment",
                title: "Literary Analysis Essay",
                description: "Write a comprehensive analysis of a selected literary work",
                status: "not-started",
                type: "assessment",
                dependencies: ["essay-writing"],
                progress: 0,
                subject: "English",
                estimatedHours: 8,
                difficulty: "advanced"
              }
            ]
          },
          {
            id: "history-path-1",
            title: "World History Journey",
            description: "Explore major historical periods and their impact on modern society",
            subject: "History",
            progress: calculateClassProgress(classProficiency, "History"),
            nodes: [
              {
                id: "ancient-civilizations",
                title: "Ancient Civilizations",
                description: "Early human societies and their contributions",
                status: "completed",
                type: "concept",
                dependencies: [],
                progress: 100,
                score: 82,
                subject: "History",
                estimatedHours: 4,
                difficulty: "beginner"
              },
              {
                id: "middle-ages",
                title: "Middle Ages",
                description: "Medieval period and feudal systems",
                status: "in-progress",
                type: "concept",
                dependencies: ["ancient-civilizations"],
                progress: 50,
                subject: "History",
                estimatedHours: 5,
                difficulty: "intermediate"
              },
              {
                id: "renaissance",
                title: "Renaissance",
                description: "Cultural and intellectual rebirth in Europe",
                status: "not-started",
                type: "concept",
                dependencies: ["middle-ages"],
                progress: 0,
                subject: "History",
                estimatedHours: 4,
                difficulty: "intermediate"
              },
              {
                id: "industrial-revolution",
                title: "Industrial Revolution",
                description: "Transformation of society through industrialization",
                status: "not-started",
                type: "concept",
                dependencies: ["renaissance"],
                progress: 0,
                subject: "History",
                estimatedHours: 5,
                difficulty: "intermediate"
              },
              {
                id: "modern-era",
                title: "Modern Era",
                description: "20th and 21st century global developments",
                status: "not-started",
                type: "concept",
                dependencies: ["industrial-revolution"],
                progress: 0,
                subject: "History",
                estimatedHours: 6,
                difficulty: "advanced"
              },
              {
                id: "history-assessment",
                title: "Historical Analysis",
                description: "Analyze historical events and their impact on contemporary society",
                status: "not-started",
                type: "assessment",
                dependencies: ["modern-era"],
                progress: 0,
                subject: "History",
                estimatedHours: 3,
                difficulty: "advanced"
              }
            ]
          }
        ];
      } else if (user.role === UserRole.EDUCATOR) {
        // For educators, get learning paths for their classes
        const educator = await storage.getEducatorByUserId(user.id);
        if (!educator) return res.status(404).json({ message: "Educator record not found" });
        
        // Get educator's classes
        const classes = await storage.getClassesByEducatorId(educator.id);
        
        // Sample/mock data - in a real system this would be retrieved from a database
        learningPaths = [
          {
            id: "class-math-path",
            title: "Class: Mathematics Curriculum",
            description: "Standard learning path for Algebra and Geometry",
            subject: "Mathematics",
            progress: 68,
            nodes: [
              {
                id: "algebra-foundations",
                title: "Algebra Foundations",
                description: "Core algebraic concepts for the class",
                status: "completed",
                type: "concept",
                dependencies: [],
                progress: 100,
                subject: "Mathematics",
                estimatedHours: 8,
                difficulty: "beginner"
              },
              {
                id: "equation-solving",
                title: "Equation Solving",
                description: "Techniques for solving various equation types",
                status: "in-progress",
                type: "skill",
                dependencies: ["algebra-foundations"],
                progress: 75,
                subject: "Mathematics",
                estimatedHours: 10,
                difficulty: "intermediate"
              },
              {
                id: "geometry-basics",
                title: "Geometry Basics",
                description: "Introduction to geometric concepts",
                status: "not-started",
                type: "concept",
                dependencies: [],
                progress: 0,
                subject: "Mathematics",
                estimatedHours: 8,
                difficulty: "beginner"
              },
              {
                id: "mid-term-assessment",
                title: "Mid-term Assessment",
                description: "Assessment of algebra and basic geometry",
                status: "not-started",
                type: "assessment",
                dependencies: ["equation-solving", "geometry-basics"],
                progress: 0,
                subject: "Mathematics",
                estimatedHours: 2,
                difficulty: "intermediate"
              },
              {
                id: "advanced-topics",
                title: "Advanced Topics",
                description: "Higher-level mathematical concepts",
                status: "not-started",
                type: "concept",
                dependencies: ["mid-term-assessment"],
                progress: 0,
                subject: "Mathematics",
                estimatedHours: 12,
                difficulty: "advanced"
              },
              {
                id: "final-assessment",
                title: "Final Assessment",
                description: "Comprehensive evaluation of all course material",
                status: "not-started",
                type: "assessment",
                dependencies: ["advanced-topics"],
                progress: 0,
                subject: "Mathematics",
                estimatedHours: 3,
                difficulty: "advanced"
              }
            ]
          },
          {
            id: "student-john-path",
            title: "John Smith's Personalized Path",
            description: "Custom learning path based on John's performance and needs",
            subject: "Mathematics",
            progress: 42,
            nodes: [
              {
                id: "john-algebra-review",
                title: "Algebra Review",
                description: "Reinforcement of core concepts where John shows weakness",
                status: "completed",
                type: "skill",
                dependencies: [],
                progress: 100,
                subject: "Mathematics",
                estimatedHours: 5,
                difficulty: "beginner"
              },
              {
                id: "john-equation-practice",
                title: "Equation Practice",
                description: "Additional practice with equations",
                status: "in-progress",
                type: "skill",
                dependencies: ["john-algebra-review"],
                progress: 60,
                subject: "Mathematics",
                estimatedHours: 6,
                difficulty: "intermediate"
              },
              {
                id: "john-advanced-concepts",
                title: "Advanced Concepts",
                description: "Accelerated topics for John's strengths",
                status: "not-started",
                type: "concept",
                dependencies: ["john-equation-practice"],
                progress: 0,
                subject: "Mathematics",
                estimatedHours: 8,
                difficulty: "advanced"
              }
            ]
          }
        ];
      } else if (user.role === UserRole.ADMIN) {
        // For admins, provide overview of all learning paths in the system
        // Get all educators to analyze their performance
        const educators = await storage.getAllEducators();
        
        // Create overview of all curriculum paths
        learningPaths = [
          {
            id: "curriculum-math",
            title: "Mathematics Curriculum",
            description: "Standard mathematics learning path for all students",
            subject: "Mathematics",
            progress: 75,
            nodes: [
              {
                id: "math-unit-1",
                title: "Unit 1: Foundations",
                description: "Foundational mathematical concepts",
                status: "completed",
                type: "concept",
                dependencies: [],
                progress: 100,
                subject: "Mathematics",
                estimatedHours: 15,
                difficulty: "beginner"
              },
              {
                id: "math-unit-2",
                title: "Unit 2: Intermediate",
                description: "Intermediate mathematical concepts",
                status: "in-progress",
                type: "concept",
                dependencies: ["math-unit-1"],
                progress: 80,
                subject: "Mathematics",
                estimatedHours: 20,
                difficulty: "intermediate"
              },
              {
                id: "math-unit-3",
                title: "Unit 3: Advanced",
                description: "Advanced mathematical concepts",
                status: "not-started",
                type: "concept",
                dependencies: ["math-unit-2"],
                progress: 0,
                subject: "Mathematics",
                estimatedHours: 25,
                difficulty: "advanced"
              }
            ]
          },
          {
            id: "curriculum-science",
            title: "Science Curriculum",
            description: "Standard science learning path for all students",
            subject: "Science",
            progress: 60,
            nodes: [
              {
                id: "science-unit-1",
                title: "Unit 1: Scientific Method",
                description: "Introduction to scientific inquiry",
                status: "completed",
                type: "concept",
                dependencies: [],
                progress: 100,
                subject: "Science",
                estimatedHours: 10,
                difficulty: "beginner"
              },
              {
                id: "science-unit-2",
                title: "Unit 2: Physics",
                description: "Basic physics concepts",
                status: "in-progress",
                type: "concept",
                dependencies: ["science-unit-1"],
                progress: 65,
                subject: "Science",
                estimatedHours: 18,
                difficulty: "intermediate"
              },
              {
                id: "science-unit-3",
                title: "Unit 3: Chemistry",
                description: "Basic chemistry concepts",
                status: "not-started",
                type: "concept",
                dependencies: ["science-unit-1"],
                progress: 0,
                subject: "Science",
                estimatedHours: 18,
                difficulty: "intermediate"
              },
              {
                id: "science-unit-4",
                title: "Unit 4: Biology",
                description: "Basic biology concepts",
                status: "not-started",
                type: "concept",
                dependencies: ["science-unit-1"],
                progress: 0,
                subject: "Science",
                estimatedHours: 18,
                difficulty: "intermediate"
              }
            ]
          }
        ];
        
        // Add educator performance path specifically for admins
        // This shows how effectively educators are implementing the learning paths
        if (educators.length > 0) {
          // Get all classes to assess teaching effectiveness
          const classes = await storage.getAllClasses();
          const grades = await storage.getAllGrades();
          
          // Create educator performance nodes
          const educatorNodes = [];
          
          for (const educator of educators) {
            // Get educator user data
            const educatorUser = await storage.getUser(educator.userId);
            if (!educatorUser) continue;
            
            // Get classes taught by this educator
            const educatorClasses = classes.filter(cls => cls.educatorId === educator.id);
            if (educatorClasses.length === 0) continue;
            
            // Calculate educator effectiveness based on student performance
            let totalScore = 0;
            let totalMaxScore = 0;
            let classesWithGrades = 0;
            
            for (const cls of educatorClasses) {
              const classGrades = grades.filter(grade => grade.classId === cls.id);
              if (classGrades.length === 0) continue;
              
              classesWithGrades++;
              for (const grade of classGrades) {
                totalScore += grade.score;
                totalMaxScore += grade.maxScore;
              }
            }
            
            // Only include educators with grade data
            if (classesWithGrades > 0) {
              const effectivenessScore = Math.round((totalScore / totalMaxScore) * 100);
              
              // Determine status based on effectiveness score
              let status = "not-started";
              if (effectivenessScore >= 90) {
                status = "mastered";
              } else if (effectivenessScore >= 80) {
                status = "completed";
              } else if (effectivenessScore >= 60) {
                status = "in-progress";
              }
              
              // Add educator as a node
              educatorNodes.push({
                id: `educator-${educator.id}`,
                title: `${educatorUser.firstName} ${educatorUser.lastName}`,
                description: `Teaching performance and curriculum implementation effectiveness`,
                status,
                type: "educator-assessment",
                dependencies: [],
                progress: effectivenessScore,
                score: effectivenessScore,
                subject: "Educator Performance",
                estimatedHours: educatorClasses.length * 4, // Rough estimate of teaching hours
                difficulty: "advanced"
              });
            }
          }
          
          // Only add educator performance path if we have data
          if (educatorNodes.length > 0) {
            learningPaths.push({
              id: "educator-performance",
              title: "Educator Performance Analysis",
              description: "Assessment of educator effectiveness in implementing learning paths",
              subject: "Educator Performance",
              progress: 100, // This is an analysis tool, not a curriculum with progress
              nodes: educatorNodes
            });
          }
        }
      }
      
      res.json(learningPaths);
    } catch (error) {
      next(error);
    }
  });
  
  // Helper function to calculate progress based on class grades
  function calculateClassProgress(
    classProficiency: Record<string, { totalScore: number, maxScore: number, count: number }>,
    subject: string
  ): number {
    if (!classProficiency[subject]) return 0;
    
    const { totalScore, maxScore } = classProficiency[subject];
    if (maxScore === 0) return 0;
    
    // Convert to percentage and roughly map to progress
    const percentage = Math.round((totalScore / maxScore) * 100);
    
    // Weighted progress based on proficiency
    if (percentage >= 90) return 85; // Almost completed path
    if (percentage >= 80) return 70;
    if (percentage >= 70) return 55;
    if (percentage >= 60) return 40;
    if (percentage >= 50) return 25;
    
    return 10; // Just started
  }
  // Classes
  app.get("/api/classes", withUserContext, async (req, res, next) => {
    try {
      // Use the user context for role-based filtering
      const classes = await storage.getAllClasses(req.userContext);
      res.json(classes);
    } catch (error) {
      next(error);
    }
  });
  
  // Students
  app.get("/api/students", 
    withUserContext, 
    requireRole([UserRole.EDUCATOR, UserRole.ADMIN]), 
    async (req, res, next) => {
      try {
        // Get only the students the user has access to based on their role and context
        const students = await storage.getAllStudents(req.userContext);
        
        // Get user details for each student
        const studentsWithDetails = await Promise.all(
          students.map(async (student) => {
            const user = await storage.getUser(student.userId);
            return {
              ...student,
              user
            };
          })
        );
        
        res.json(studentsWithDetails);
      } catch (error) {
        next(error);
      }
    }
  );
  
  // Grades
  app.get("/api/grades/student/:studentId", withUserContext, async (req, res, next) => {
    try {
      const studentId = parseInt(req.params.studentId, 10);
      const user = req.userContext as User;
      
      // If student is requesting grades, verify it's their own data
      if (user.role === UserRole.STUDENT) {
        const student = await storage.getStudentByUserId(user.id);
        if (!student) return res.status(404).json({ message: "Student record not found" });
        
        if (student.id !== studentId) {
          return res.status(403).json({ message: "Access denied" });
        }
      }
      
      // Get accessible grades based on user context
      const grades = await storage.getAccessibleGrades(user);
      
      // Filter grades for the specific student
      const studentGrades = grades.filter(grade => grade.studentId === studentId);
      
      // Get class details for each grade
      const gradesWithClassDetails = await Promise.all(
        studentGrades.map(async (grade) => {
          const cls = await storage.getClass(grade.classId);
          return {
            ...grade,
            class: cls
          };
        })
      );
      
      res.json(gradesWithClassDetails);
    } catch (error) {
      next(error);
    }
  });
  
  app.get("/api/grades/class/:classId", 
    withUserContext, 
    requireRole([UserRole.EDUCATOR, UserRole.ADMIN]), 
    async (req, res, next) => {
      try {
        const classId = parseInt(req.params.classId, 10);
        const user = req.userContext as User;
        
        // Get accessible classes based on user context
        const accessibleClasses = await storage.getAccessibleClasses(user);
        
        // Check if the requested class is accessible
        const hasAccess = accessibleClasses.some(cls => cls.id === classId);
        if (!hasAccess) {
          return res.status(403).json({ message: "Access denied for this class" });
        }
        
        const grades = await storage.getGradesByClassId(classId);
        res.json(grades);
      } catch (error) {
        next(error);
      }
    }
  );
  
  // Attendance
  app.get("/api/attendance/student/:studentId", withUserContext, async (req, res, next) => {
    try {
      const studentId = parseInt(req.params.studentId, 10);
      const user = req.userContext as User;
      
      // If student is requesting attendance data, verify it's their own
      if (user.role === UserRole.STUDENT) {
        const student = await storage.getStudentByUserId(user.id);
        if (!student) return res.status(404).json({ message: "Student record not found" });
        
        if (student.id !== studentId) {
          return res.status(403).json({ message: "Access denied" });
        }
      }
      
      // Get accessible attendance records based on user context
      const attendanceRecords = await storage.getAccessibleAttendance(user);
      
      // Filter attendance for the specific student
      const studentAttendance = attendanceRecords.filter(record => record.studentId === studentId);
      
      res.json(studentAttendance);
    } catch (error) {
      next(error);
    }
  });
  
  app.get("/api/attendance/class/:classId", 
    withUserContext, 
    requireRole([UserRole.EDUCATOR, UserRole.ADMIN]), 
    async (req, res, next) => {
      try {
        const classId = parseInt(req.params.classId, 10);
        const user = req.userContext as User;
        
        // Get accessible classes based on user context
        const accessibleClasses = await storage.getAccessibleClasses(user);
        
        // Check if the requested class is accessible
        const hasAccess = accessibleClasses.some(cls => cls.id === classId);
        if (!hasAccess) {
          return res.status(403).json({ message: "Access denied for this class" });
        }
        
        // Get attendance records for the class
        const attendance = await storage.getAttendanceByClassId(classId);
        res.json(attendance);
      } catch (error) {
        next(error);
      }
    }
  );
  
  // Analytics API for performance metrics
  // Endpoint for educator performance metrics (primarily for admins)
  app.get("/api/analytics/educator-performance", withUserContext, requireRole([UserRole.ADMIN]), async (req, res, next) => {
    try {
      // Get all educators
      const educators = await storage.getAllEducators();
      const educatorPerformanceData = [];
      
      for (const educator of educators) {
        // Get educator user data
        const educatorUser = await storage.getUser(educator.userId);
        if (!educatorUser) continue;
        
        // Get classes taught by this educator
        const educatorClasses = await storage.getClassesByEducatorId(educator.id);
        if (educatorClasses.length === 0) continue;
        
        // Get department
        let departmentName = "General";
        if (educator.departmentId) {
          const department = await storage.getDepartment(educator.departmentId);
          if (department) {
            departmentName = department.name;
          }
        }
        
        // Get school
        let schoolName = "Unknown School";
        if (educator.schoolId) {
          const school = await storage.getSchool(educator.schoolId);
          if (school) {
            schoolName = school.name;
          }
        }
        
        // Get district
        let districtName = "Unknown District";
        if (educator.districtId) {
          const district = await storage.getDistrict(educator.districtId);
          if (district) {
            districtName = district.name;
          }
        }
        
        // Calculate performance metrics
        let totalGradePoints = 0;
        let totalMaxPoints = 0;
        let totalStudents = 0;
        let classEngagement = 0;
        
        for (const cls of educatorClasses) {
          // Get enrollments for the class
          const enrollments = await storage.getEnrollmentsByClassId(cls.id);
          totalStudents += enrollments.length;
          
          // Get grades
          const grades = await storage.getGradesByClassId(cls.id);
          let classTotal = 0;
          let classMax = 0;
          
          for (const grade of grades) {
            classTotal += grade.score;
            classMax += grade.maxScore;
          }
          
          if (classMax > 0) {
            totalGradePoints += classTotal;
            totalMaxPoints += classMax;
          }
          
          // Calculate engagement from attendance (if available)
          const attendance = await storage.getAttendanceByClassId(cls.id);
          if (attendance.length > 0 && enrollments.length > 0) {
            const attendanceRate = attendance.filter(a => a.present).length / attendance.length;
            classEngagement += attendanceRate * 100;
          }
        }
        
        // Calculate final metrics
        const evaluationScore = totalMaxPoints > 0 
          ? Math.round((totalGradePoints / totalMaxPoints) * 100) 
          : 60; // Default if no grades
          
        const studentOutcomes = totalMaxPoints > 0 
          ? Math.round((totalGradePoints / totalMaxPoints) * 100) 
          : 60; // Same as evaluation for now
          
        const avgClassEngagement = educatorClasses.length > 0 
          ? Math.round(classEngagement / educatorClasses.length) 
          : 70; // Default if no attendance data
          
        // Generate strengths and improvement areas based on metrics
        const strengths = [];
        const improvementAreas = [];
        
        if (evaluationScore >= 85) strengths.push("Student achievement");
        if (avgClassEngagement >= 85) strengths.push("Student engagement");
        if (educatorClasses.length >= 3) strengths.push("Course management");
        
        if (evaluationScore < 70) {
          improvementAreas.push({
            area: "Student achievement",
            priority: "high"
          });
        } else if (evaluationScore < 80) {
          improvementAreas.push({
            area: "Student achievement",
            priority: "medium"
          });
        }
        
        if (avgClassEngagement < 70) {
          improvementAreas.push({
            area: "Student engagement",
            priority: "high"
          });
        } else if (avgClassEngagement < 80) {
          improvementAreas.push({
            area: "Student engagement",
            priority: "medium"
          });
        }
        
        // Add feedback based on performance
        let recentFeedback = "";
        if (evaluationScore >= 90) {
          recentFeedback = "Excellent performance across all metrics. Keep up the outstanding work with students.";
        } else if (evaluationScore >= 80) {
          recentFeedback = "Good progress with student achievement. Consider more advanced engagement techniques.";
        } else if (evaluationScore >= 70) {
          recentFeedback = "Adequately meeting requirements. Focus on areas for improvement to enhance student outcomes.";
        } else {
          recentFeedback = "Needs significant improvement in student outcomes. Recommend additional training and mentoring.";
        }
        
        // Prepare expertise based on classes taught
        const expertise = educatorClasses.map(cls => cls.name);
        
        // Add to performance data
        educatorPerformanceData.push({
          id: educator.id,
          name: `${educatorUser.firstName} ${educatorUser.lastName}`,
          department: departmentName,
          school: schoolName,
          district: districtName,
          evaluationScore,
          studentOutcomes,
          classEngagement: avgClassEngagement,
          expertise: [...new Set(expertise)], // Remove duplicates
          yearOfExperience: educatorUser.createdAt ? 
            Math.floor((Date.now() - new Date(educatorUser.createdAt).getTime()) / (365 * 24 * 60 * 60 * 1000)) + 1 : 
            1,
          adminLevel: educatorUser.adminLevel || null,
          strengths,
          improvementAreas,
          recentFeedback
        });
      }
      
      // Sort by performance score (low to high to highlight educators needing help)
      educatorPerformanceData.sort((a, b) => a.evaluationScore - b.evaluationScore);
      
      res.json(educatorPerformanceData);
    } catch (error) {
      next(error);
    }
  });

  app.get("/api/analytics/performance", withUserContext, async (req, res, next) => {
    try {
      const user = req.userContext as User;
      let result;
      
      if (user.role === UserRole.STUDENT) {
        // Get student's own performance
        const student = await storage.getStudentByUserId(user.id);
        if (!student) return res.status(404).json({ message: "Student record not found" });
        
        // Get accessible grades based on user context (should only be student's own grades)
        const accessibleGrades = await storage.getAccessibleGrades(user);
        
        // Group grades by class
        const performance: Record<string, { totalScore: number, maxScore: number, count: number }> = {};
        for (const grade of accessibleGrades) {
          const cls = await storage.getClass(grade.classId);
          if (!cls) continue;
          
          if (!performance[cls.name]) {
            performance[cls.name] = {
              totalScore: 0,
              maxScore: 0,
              count: 0
            };
          }
          
          performance[cls.name].totalScore += grade.score;
          performance[cls.name].maxScore += grade.maxScore;
          performance[cls.name].count += 1;
        }
        
        // Calculate average percentages
        const metrics = Object.entries(performance).map(([subject, data]) => {
          const { totalScore, maxScore } = data;
          return {
            subject,
            percentage: maxScore > 0 ? Math.round((totalScore / maxScore) * 100) : 0
          };
        });
        
        result = {
          metrics,
          insights: [
            {
              type: "improvement",
              title: "Improvement Opportunity",
              description: "Focus on subjects where your scores are below 75% to improve overall performance."
            },
            {
              type: "success",
              title: "Success Pattern",
              description: "You're performing well in subjects above 85%. Keep up the good work!"
            }
          ]
        };
      } else if (user.role === UserRole.EDUCATOR) {
        // For educators, only show data for their classes
        const educator = await storage.getEducatorByUserId(user.id);
        if (!educator) return res.status(404).json({ message: "Educator record not found" });
        
        // Get educator's classes
        const classes = await storage.getClassesByEducatorId(educator.id);
        
        // Get grades for each class
        const classGrades = await Promise.all(
          classes.map(async cls => {
            const grades = await storage.getGradesByClassId(cls.id);
            
            // Calculate class average
            let totalScore = 0;
            let maxScore = 0;
            for (const grade of grades) {
              totalScore += grade.score;
              maxScore += grade.maxScore;
            }
            
            const percentage = maxScore > 0 ? Math.round((totalScore / maxScore) * 100) : 0;
            
            return {
              subject: cls.name,
              percentage
            };
          })
        );
        
        result = { 
          metrics: classGrades,
          insights: [
            {
              type: "improvement",
              title: "Improvement Opportunity",
              description: "Classes scoring below 75% average may benefit from additional review or alternative teaching methods."
            },
            {
              type: "success",
              title: "Success Pattern Detected",
              description: "Interactive learning activities correlate with 15% higher engagement and 8% better test results based on last month's data."
            },
            {
              type: "warning",
              title: "Attendance Pattern",
              description: "Three students showing inconsistent Monday attendance over the past 3 weeks - may require follow-up."
            }
          ]
        };
      } else if (user.role === UserRole.ADMIN) {
        // For admins, show data based on their admin level (district, school, or department)
        // Get accessible schools based on the admin's level
        const accessibleSchools = await storage.getAccessibleSchools(user);
        
        // Get departments from those schools
        const departmentIds = new Set<number>();
        for (const school of accessibleSchools) {
          const departments = await storage.getDepartmentsBySchoolId(school.id);
          for (const dept of departments) {
            departmentIds.add(dept.id);
          }
        }
        
        // Get classes from those departments
        const classIds = new Set<number>();
        for (const deptId of Array.from(departmentIds)) {
          const classes = await storage.getClassesByDepartmentId(deptId);
          for (const cls of classes) {
            classIds.add(cls.id);
          }
        }
        
        // Calculate overall metrics by subject area
        const subjectPerformance: Record<string, { totalScore: number, maxScore: number, count: number }> = {};
        
        for (const classId of Array.from(classIds)) {
          const cls = await storage.getClass(classId);
          if (!cls) continue;
          
          const grades = await storage.getGradesByClassId(classId);
          
          // Get department for subject categorization if available
          let subjectCategory = cls.name; // Default to class name
          
          if (cls.departmentId) {
            const department = await storage.getDepartment(cls.departmentId);
            if (department) {
              subjectCategory = department.name; // Use department name as subject category
            }
          }
          
          if (!subjectPerformance[subjectCategory]) {
            subjectPerformance[subjectCategory] = {
              totalScore: 0,
              maxScore: 0,
              count: 0
            };
          }
          
          for (const grade of grades) {
            subjectPerformance[subjectCategory].totalScore += grade.score;
            subjectPerformance[subjectCategory].maxScore += grade.maxScore;
            subjectPerformance[subjectCategory].count += 1;
          }
        }
        
        // Calculate metrics
        const metrics = Object.entries(subjectPerformance).map(([subject, data]) => {
          const { totalScore, maxScore } = data;
          return {
            subject,
            percentage: maxScore > 0 ? Math.round((totalScore / maxScore) * 100) : 0
          };
        });
        
        result = { 
          metrics,
          insights: [
            {
              type: "improvement",
              title: "Improvement Opportunity",
              description: "Science department scores are trending 5% lower than last semester. Consider curriculum review or additional teacher support."
            },
            {
              type: "success",
              title: "Success Pattern Detected",
              description: "Schools implementing the new math curriculum show 7% higher scores on average compared to traditional methods."
            },
            {
              type: "warning",
              title: "Resource Allocation",
              description: "Three classes have more than 30 students, which correlates with lower performance scores. Consider rebalancing class sizes."
            }
          ]
        };
      } else {
        // Fallback for other roles or unknown roles
        result = { 
          metrics: [],
          insights: []
        };
      }
      
      res.json(result);
    } catch (error) {
      next(error);
    }
  });

  // Achievement API endpoints
  app.get("/api/achievements", withUserContext, async (req, res, next) => {
    try {
      const user = req.userContext as User;
      const achievements = await storage.getAccessibleAchievements(user);
      res.json(achievements);
    } catch (error) {
      next(error);
    }
  });

  app.get("/api/achievements/user/:userId", withUserContext, async (req, res, next) => {
    try {
      const currentUser = req.userContext as User;
      const userId = parseInt(req.params.userId, 10);
      
      // Get all achievements for the specified user
      const achievements = await storage.getAchievementsByUserId(userId);
      
      // Filter achievements based on access permissions
      let authorizedAchievements = achievements;
      
      // If not requesting own achievements and not an admin, filter to only public achievements
      if (currentUser.id !== userId && currentUser.role !== UserRole.ADMIN) {
        authorizedAchievements = achievements.filter(achievement => 
          achievement.isPublic || 
          (currentUser.role === UserRole.EDUCATOR && achievement.createdByEducator)
        );
      }
      
      res.json(authorizedAchievements);
    } catch (error) {
      next(error);
    }
  });

  app.get("/api/achievements/subject/:subject", withUserContext, async (req, res, next) => {
    try {
      const user = req.userContext as User;
      const subject = req.params.subject;
      
      // Get achievements by subject
      const subjectAchievements = await storage.getAchievementsBySubject(subject);
      
      // Filter to only achievements the user has access to
      const accessibleAchievements = await storage.getAccessibleAchievements(user);
      const authorizedAchievements = subjectAchievements.filter(achievement => 
        accessibleAchievements.some(a => a.id === achievement.id)
      );
      
      res.json(authorizedAchievements);
    } catch (error) {
      next(error);
    }
  });

  app.get("/api/achievements/type/:type", withUserContext, async (req, res, next) => {
    try {
      const user = req.userContext as User;
      const type = req.params.type;
      
      // Get achievements by type
      const typeAchievements = await storage.getAchievementsByType(type);
      
      // Filter to only achievements the user has access to
      const accessibleAchievements = await storage.getAccessibleAchievements(user);
      const authorizedAchievements = typeAchievements.filter(achievement => 
        accessibleAchievements.some(a => a.id === achievement.id)
      );
      
      res.json(authorizedAchievements);
    } catch (error) {
      next(error);
    }
  });

  app.post("/api/achievements", withUserContext, requireRole([UserRole.EDUCATOR, UserRole.ADMIN]), async (req, res, next) => {
    try {
      const user = req.userContext as User;
      
      // Validate the request body
      const parsedBody = insertAchievementSchema.parse({
        ...req.body,
        createdByEducator: user.role === UserRole.EDUCATOR,
        isPublic: req.body.isPublic ?? false,
        earnedAt: req.body.earnedAt || new Date().toISOString()
      });
      
      const newAchievement = await storage.createAchievement(parsedBody);
      res.status(201).json(newAchievement);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid achievement data", errors: error.format() });
      }
      next(error);
    }
  });

  // AI Tutoring Routes - Students only
  app.get("/api/tutor/session", withUserContext, requireRole([UserRole.STUDENT]), async (req, res, next) => {
    try {
      const user = req.userContext as User;
      const student = await storage.getStudentByUserId(user.id);
      if (!student) return res.status(404).json({ message: "Student record not found" });

      const subject = req.query.subject as string || "General";
      const topic = req.query.topic as string || null;

      // Get active session or create new one
      let session = await storage.getActiveTutoringSession(student.id);
      if (!session) {
        // Validate input before creating session
        const sessionInput = insertTutoringSessionSchema.parse({
          studentId: student.id,
          startedAt: new Date().toISOString(),
          subject,
          topic,
          difficulty: "intermediate"
        });
        session = await storage.createTutoringSession(sessionInput);
      } else if (session.subject !== subject) {
        // If subject changed, end current session and start new one
        await storage.updateTutoringSession(session.id, {
          endedAt: new Date().toISOString()
        });
        const sessionInput = insertTutoringSessionSchema.parse({
          studentId: student.id,
          startedAt: new Date().toISOString(),
          subject,
          topic,
          difficulty: "intermediate"
        });
        session = await storage.createTutoringSession(sessionInput);
      }

      // Get all messages for this session
      const messages = await storage.getTutoringMessagesBySessionId(session.id);
      
      res.json({ session, messages });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid session data", errors: error.format() });
      }
      next(error);
    }
  });

  app.post("/api/tutor/message", withUserContext, requireRole([UserRole.STUDENT]), async (req, res, next) => {
    try {
      const user = req.userContext as User;
      const student = await storage.getStudentByUserId(user.id);
      if (!student) return res.status(404).json({ message: "Student record not found" });

      const { message: userMessage, sessionId } = req.body;
      if (!userMessage || !sessionId) {
        return res.status(400).json({ message: "Message and sessionId are required" });
      }

      // Get the session
      const session = await storage.getTutoringSession(sessionId);
      if (!session || session.studentId !== student.id) {
        return res.status(404).json({ message: "Session not found" });
      }

      // Validate and save user message with Zod
      const userMessageInput = insertTutoringMessageSchema.parse({
        sessionId: session.id,
        role: "user",
        content: userMessage,
        timestamp: new Date().toISOString(),
        conceptsDiscussed: []
      });
      await storage.createTutoringMessage(userMessageInput);

      // Get all previous messages for context
      const allMessages = await storage.getTutoringMessagesBySessionId(session.id);
      const conversationHistory: TutorMessage[] = allMessages.map(msg => ({
        role: msg.role as "user" | "assistant",
        content: msg.content
      }));

      // FERPA COMPLIANCE: Build student context for PII redaction
      const userRecord = await storage.getUser(user.id);
      const school = student.schoolId ? await storage.getSchool(student.schoolId) : null;
      const studentContext = {
        fullName: userRecord ? `${userRecord.firstName} ${userRecord.lastName}` : undefined,
        email: userRecord?.email,
        studentId: student.studentId || undefined,
        schoolName: school?.name || undefined
      };

      // Get AI response with comprehensive PII redaction
      const tutorResponse = await getTutorResponse(
        conversationHistory,
        session.subject || undefined,
        session.topic || undefined,
        studentContext
      );

      // Validate and save AI response
      const aiMessageInput = insertTutoringMessageSchema.parse({
        sessionId: session.id,
        role: "assistant",
        content: tutorResponse.message,
        timestamp: new Date().toISOString(),
        conceptsDiscussed: tutorResponse.conceptsDiscussed
      });
      await storage.createTutoringMessage(aiMessageInput);

      // Update session stats with all tracked metadata
      const allConcepts = [...new Set([...(session.conceptsCovered || []), ...tutorResponse.conceptsDiscussed])];
      await storage.updateTutoringSession(session.id, {
        totalMessages: session.totalMessages + 2,
        studentQuestions: session.studentQuestions + 1,
        conceptsCovered: allConcepts
      });

      res.json({ 
        message: tutorResponse.message,
        conceptsDiscussed: tutorResponse.conceptsDiscussed
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid message data", errors: error.format() });
      }
      console.error("Tutor message error:", error);
      next(error);
    }
  });

  app.post("/api/tutor/session/end", withUserContext, requireRole([UserRole.STUDENT]), async (req, res, next) => {
    try {
      const user = req.userContext as User;
      const student = await storage.getStudentByUserId(user.id);
      if (!student) return res.status(404).json({ message: "Student record not found" });

      const { sessionId } = req.body;
      const session = await storage.getTutoringSession(sessionId);
      if (!session || session.studentId !== student.id) {
        return res.status(404).json({ message: "Session not found" });
      }

      // Get all messages for summary generation
      const messages = await storage.getTutoringMessagesBySessionId(session.id);
      const conversationHistory: TutorMessage[] = messages.map(msg => ({
        role: msg.role as "user" | "assistant" | "system",
        content: msg.content
      }));

      // FERPA COMPLIANCE: Build student context for PII redaction in summary
      const userRecord = await storage.getUser(user.id);
      const school = student.schoolId ? await storage.getSchool(student.schoolId) : null;
      const studentContext = {
        fullName: userRecord ? `${userRecord.firstName} ${userRecord.lastName}` : undefined,
        email: userRecord?.email,
        studentId: student.studentId || undefined,
        schoolName: school?.name || undefined
      };

      // Generate session summary with PII redaction
      const summary = await generateSessionSummary(
        conversationHistory,
        session.subject || undefined,
        session.topic || undefined,
        studentContext
      );

      // Update session with summary and end time
      const updatedSession = await storage.updateTutoringSession(session.id, {
        endedAt: new Date().toISOString(),
        sessionSummary: summary.summary,
        performanceScore: summary.performanceScore,
        improvementAreas: summary.improvementAreas,
        strengthAreas: summary.strengthAreas,
        conceptsCovered: summary.conceptsCovered
      });

      res.json(updatedSession);
    } catch (error) {
      console.error("End session error:", error);
      next(error);
    }
  });

  app.get("/api/tutor/sessions/history", withUserContext, requireRole([UserRole.STUDENT, UserRole.EDUCATOR, UserRole.ADMIN]), async (req, res, next) => {
    try {
      const user = req.userContext as User;

      if (user.role === UserRole.STUDENT) {
        const student = await storage.getStudentByUserId(user.id);
        if (!student) return res.status(404).json({ message: "Student record not found" });
        const sessions = await storage.getTutoringSessionsByStudentId(student.id);
        res.json(sessions);
      } else {
        // Educators and admins can view all sessions (for now - could be filtered)
        res.json([]);
      }
    } catch (error) {
      next(error);
    }
  });

  // Get AI-generated progress insights for student
  app.get("/api/tutor/progress-insights", withUserContext, requireRole([UserRole.STUDENT]), async (req, res, next) => {
    try {
      const user = req.userContext as User;
      const student = await storage.getStudentByUserId(user.id);
      if (!student) return res.status(404).json({ message: "Student record not found" });

      // Get all tutoring sessions
      const sessions = await storage.getTutoringSessionsByStudentId(student.id);

      if (sessions.length === 0) {
        return res.json({
          overallProgress: "Just getting started! Begin your learning journey by choosing a subject.",
          strengths: [],
          areasForImprovement: [],
          recommendations: ["Start by exploring subjects you're curious about", "Don't hesitate to ask questions - that's how you learn!", "Take your time and enjoy the process"],
          weeklyGoal: "Complete your first tutoring session",
          totalSessions: 0,
          totalTime: 0,
          subjectBreakdown: {}
        });
      }

      // Calculate statistics
      const totalSessions = sessions.length;
      const totalTime = sessions.reduce((acc, session) => {
        if (session.startedAt && session.endedAt) {
          const start = new Date(session.startedAt).getTime();
          const end = new Date(session.endedAt).getTime();
          return acc + (end - start) / 1000 / 60; // minutes
        }
        return acc;
      }, 0);

      // Group by subject
      const subjectBreakdown: Record<string, { sessions: number; time: number; avgPerformance: number }> = {};
      sessions.forEach(session => {
        if (session.subject) {
          if (!subjectBreakdown[session.subject]) {
            subjectBreakdown[session.subject] = { sessions: 0, time: 0, avgPerformance: 0 };
          }
          subjectBreakdown[session.subject].sessions++;
          if (session.startedAt && session.endedAt) {
            const start = new Date(session.startedAt).getTime();
            const end = new Date(session.endedAt).getTime();
            subjectBreakdown[session.subject].time += (end - start) / 1000 / 60;
          }
          if (session.performanceScore) {
            subjectBreakdown[session.subject].avgPerformance += session.performanceScore;
          }
        }
      });

      // Calculate average performance per subject
      Object.keys(subjectBreakdown).forEach(subject => {
        subjectBreakdown[subject].avgPerformance =
          subjectBreakdown[subject].avgPerformance / subjectBreakdown[subject].sessions;
      });

      // Generate AI insights based on session data
      const recentSessions = sessions.slice(-10); // Last 10 sessions
      const conceptsCovered = recentSessions.flatMap(s => s.conceptsCovered || []);
      const strengthAreas = recentSessions.flatMap(s => s.strengthAreas || []);
      const improvementAreas = recentSessions.flatMap(s => s.improvementAreas || []);

      // Use AI to generate personalized insights
      const insightsPrompt = `As an encouraging AI tutor for a 9th grade student, analyze their learning progress and provide warm, motivational insights.

Student Stats:
- Total Sessions: ${totalSessions}
- Total Study Time: ${Math.round(totalTime)} minutes
- Subjects Studied: ${Object.keys(subjectBreakdown).join(", ")}
- Recent Concepts Covered: ${conceptsCovered.slice(0, 10).join(", ")}
- Identified Strengths: ${strengthAreas.slice(0, 5).join(", ")}
- Areas for Growth: ${improvementAreas.slice(0, 5).join(", ")}

Provide a JSON response with:
{
  "overallProgress": "A warm, encouraging 2-3 sentence summary of their overall progress",
  "strengths": ["3-5 specific strengths you've noticed"],
  "areasForImprovement": ["2-3 areas where gentle growth is happening"],
  "recommendations": ["3-4 specific, actionable suggestions for this week"],
  "weeklyGoal": "One achievable, motivating goal for this week"
}

Important: Be warm, encouraging, and celebrate effort. Use language that makes the student feel proud and motivated.`;

      try {
        const aiResponse = await getTutorResponse([
          { role: "user", content: insightsPrompt }
        ], "general");

        // Parse AI response
        const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          const insights = JSON.parse(jsonMatch[0]);
          res.json({
            ...insights,
            totalSessions,
            totalTime: Math.round(totalTime),
            subjectBreakdown
          });
        } else {
          throw new Error("Could not parse AI response");
        }
      } catch (error) {
        // Fallback if AI fails
        res.json({
          overallProgress: `You've completed ${totalSessions} tutoring sessions and spent ${Math.round(totalTime)} minutes learning! That's fantastic dedication. Keep up the great work!`,
          strengths: strengthAreas.slice(0, 3).filter((v, i, a) => a.indexOf(v) === i),
          areasForImprovement: improvementAreas.slice(0, 3).filter((v, i, a) => a.indexOf(v) === i),
          recommendations: [
            "Continue practicing the concepts you've been working on",
            "Try exploring a new subject area this week",
            "Don't hesitate to ask questions when something isn't clear"
          ],
          weeklyGoal: "Complete 3 more tutoring sessions this week",
          totalSessions,
          totalTime: Math.round(totalTime),
          subjectBreakdown
        });
      }
    } catch (error) {
      next(error);
    }
  });

  const httpServer = createServer(app);

  return httpServer;
}
